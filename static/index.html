<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
      line.dashed {
        stroke: #aaa;
        stroke-width: 1px;
        stroke-dasharray: 2;
      }
      .row {
        display: flex;
        flex-direction: row;
      }
      .col {
        width:400px;
        display: flex;
        flex-direction: column;
      }
    </style>
  </head>
  <body>
  <div class="row">
    <div class="col">
    <div class="row">
      <div class="slide">
        <h3>Category</h3>
        <input type="range" id="category" min=0 max=1 step=0.1 />
      </div>
      <div class="slide">
        <h3>Neighborhood</h3>
        <input type="range" id="neighborhood" min=0 max=1 step=0.1 />
      </div>
      <div class="slide">
        <h3>Rating</h3>
        <input type="range" id="rating" min=0 max=1 step=0.1 />
      </div>
    </div>
    <h3>Choose your Neighborhood</h3>
    <div id="neigh-buttons"></div>
    <h3>Choose your Category</h3>
    <div id="cat-buttons"></div>
    <h3>Choose your Rating</h3>
    <div id="rat-buttons"></div>
</div>
<svg id="bubble" height="400" width="700"></svg>
</div>
</div>

    <script>
      const bubble = d3.select("#bubble");
      const width = bubble.attr("width");
      const height = bubble.attr("height");
      const margins = { top: 10, bottom: 10, left: 30, right: 30 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      let annotations = bubble.append("g").attr("id", "annotations");
      let points = bubble
        .append("g")
        .attr("id", "points")
        .attr(
          "transform",
          "translate(" + margins.left + "," + margins.top + ")"
        );

      //initialization of global vars
      var categoryWeight = 1;
      var chosenCategory = [];
      var neighborhoodWeight = 1;
      var chosenNeighborhood = [];
      var ratingWeight = 1;
      var chosenRating = [];

      const requestData = async function () {
        //LOAD DATA
        const restaurants = await d3.json("yelp_boston.json", d3.autoType);
        console.log(restaurants);

        var neighborhood = d3.map(restaurants, (d) => d["neighborhood"]);
        var neighborhoodList = [...new Set(neighborhood)];
        var category = d3.map(restaurants, (d) => d["categories"]);
        var categoryList = [];
        var rating = d3.map(restaurants, (d) => d["rating"]);
        var ratingList = [...new Set(rating)];

        neighborhoodList = neighborhoodList.filter((d) => d !== "");

        restaurants.forEach((d) => {
          d["score"] = calculateScore(d);
          d.x = d3.randomUniform(0, chartWidth)();
          d.y = d3.randomUniform(0, chartHeight)();
          d["categories"].forEach((c) => {
            if (!categoryList.includes(c)) {
              categoryList.push(c);
            }
          });
        });

        neighborhoodList = neighborhoodList.filter((d) => d !== "");
        console.log(categoryList);
        console.log(neighborhoodList);
        // create sliders
        d3.select("#category")
          .attr('value', 1)
          .on("input", function () {
            categoryWeight = parseInt(d3.select(this).property("value"));
            resetSim();
        });
        d3.select("#neighborhood")
          .attr('value', 1)
          .on("input", function () {
            neighborhoodWeight = parseInt(d3.select(this).property("value"));
            resetSim();
        });
        d3.select("#rating")
          .attr('value', 1)
          .on("input", function () {
            ratingWeight = d3.select(this).property("value");
            console.log("ratingweight",ratingWeight)
            resetSim();
        });

        const scoreExtent = d3.extent(restaurants, (d) => d.score);
        const scoreScale = d3
          .scaleLinear()
          .domain(scoreExtent)
          .range([0, chartWidth]);
        const radScale = d3.scaleLinear().domain(scoreExtent).range([2, 10]);
        const forceScale = d3.scaleLinear().domain(scoreExtent).range([150, 0]);

        // annotations
        //   .append("line")
        //   .attr("x1", scoreScale(scoreExtent[0]) + margins.left)
        //   .attr("x2", scoreScale(scoreExtent[1]) + margins.left)
        //   .attr("y1", chartHeight / 2 + margins.top)
        //   .attr("y2", chartHeight / 2 + margins.top)
        //   .attr("class", "dashed");

        // var scoreAxis = d3.axisBottom(scoreScale);
        // annotations
        //   .append("g")
        //   .attr("class", "x axis")
        //   .attr(
        //     "transform",
        //     `translate(${margins.left},${chartHeight - margins.top})`
        //   )
        //   .call(scoreAxis);

        points
          .selectAll("circle")
          .data(restaurants)
          .join("circle")
          .attr("r", (d) => radScale(d.score))
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)

          .attr("fill", "steelblue");

        var simulation = d3
          .forceSimulation()
          .nodes(restaurants)
          // .force("center", d3.forceCenter()
          //                    .x(chartHeight/2)
          //                    .y(chartWidth/2)
          //                    .strength(0.05))
          .force(
            "radial",
            d3
              .forceRadial()
              .x(chartWidth / 2)
              .y(chartHeight / 2)
              .radius((d) => forceScale(d.score))
              .strength(1)
          )
          // .force("ypos", d3.forceY()
          //                  .y(chartHeight/2)
          //                  .strength(0.05))
          // .force("xpos", d3.forceX()
          //                  .x(d => {
          //                    // console.log(d)
          //                    // console.log(scoreScale(d.score))
          //                    return scoreScale(d.score)
          //                  })
          //                  .strength(0.05))
          .force(
            "collision",
            d3
              .forceCollide()
              .radius((d) => radScale(d.score) + 2)
              .iterations(2)
          )
          .on("tick", updatePoints);

        // simulation.stop();
        // simulation.restart();

        function updatePoints() {
          points
            .selectAll("circle")
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y);
        }

        function updateScores() {
          restaurants.forEach(d => {
            d.score = calculateScore(d)
          })
        }

        function resetSim() {
          updateScores();
          simulation.nodes(restaurants)
          simulation.alpha(1);
          simulation.restart();
        }

        function createFilters() {
          // neighbors
          neighbor_div = d3.select("div#neigh-buttons");
          neighborhoodList.forEach((d) => {
            neighbor_div
              .append("button")
              .text(d)
              .on("click", function () {
                chosenNeighborhood = d3.select(this).text();
              });
          });
          // category
          category_div = d3.select("div#cat-buttons");
          categoryList.forEach((d) => {
            category_div
              .append("button")
              .text(d)
              .on("click", function () {
                chosenCategory = d3.select(this).text();
              });
          });
          // rating list
          rating_div = d3.select("div#rat-buttons");
          ratingList.forEach((d) => {
            rating_div
              .append("button")
              .text(d)
              .on("click", function () {
                chosenRating = d3.select(this).text();
              });
          });
        }

        createFilters();
      }; //END REQUEST DATA
      // citation: https://www.codespeedy.com/get-common-elements-from-two-arrays-in-javascript/
      function getCommon(arr1, arr2) {
        // var common = []; // Array to contain common elements
        // for (var i = 0; i < arr1.length; ++i) {
        //   for (var j = 0; j < arr2.length; ++j) {
        //     if (arr1[i] == arr2[j]) {
        //       // If element is in both the arrays
        //       common.push(arr1[i]); // Push to common array
        //     }
        //   }
        // }
        // console.log(arr1)
        common = [...arr1].filter(d => arr2.includes(d));

        return common
      }
      function calculateScore(d) {
        console.log(ratingWeight)
        rating = d.rating;
        cat = 0;
        neigh = 0;
        commonCategory = getCommon(d.categories, chosenCategory);
        // commonRating = getCommon(rating, chosenRating);
        commonNeighborhood = getCommon(d.neighborhood, chosenNeighborhood);
        // console.log(commonNeighborhood);
        // console.log(commonRating);
        // console.log(commonCategory);
        if (commonCategory.length > 0) {
          cat = commonCategory.length;
        } else {
          cat = 0;
        }
        // if (commonRating.length > 0) {
        //   res = commonRating.length;
        // } else {
        //   res = 0;
        // }
        if (commonNeighborhood.length > 0) {
          neigh = 1;
        } else {
          neigh = 0;
        }
        // console.log(ratingWeight)
        var final =
          neigh * parseInt(neighborhoodWeight) +
          rating * ratingWeight +
          cat * parseInt(categoryWeight);
        // console.log(final)
        return final;
      }
      requestData();
    </script>
  </body>
</html>
