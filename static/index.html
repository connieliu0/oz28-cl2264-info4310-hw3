<html>
  <head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
      body{
        font-family: Palatino;
      }
      button {
        font-size: 12px;
        padding: 5px;
        margin: 2px;
        border: #d3d6da solid 0px;
        color: #000000;
        background-color: #ddecff;
      }
      button:hover {
        margin: 2px;
        border: #d3d6da solid 2px;
        color: #ffffff;
        border: #d3d6da solid 0px;
        background-color: rgb(105, 116, 216);
      }
      .clicked{
        margin: 2px;
        border: #d3d6da solid 2px;
        color: #ffffff;
        border: #d3d6da solid 0px;
        background-color: rgb(105, 116, 216);
      }
      line.dashed {
        stroke: #aaa;
        stroke-width: 1px;
        stroke-dasharray: 2;
      }
      .row {
        display: flex;
        flex-direction: row;
      }
      .col {
        display: flex;
        flex-direction: column;
        margin-right: 40px;
      }
      #filters{
        width:1000px;
      }
    </style>
  </head>
  <body>
  <div class="row">
    <div class="col" id ="filters">
    <div class="row" id="sliders">
      <div class="slide">
        <h3>Category</h3>
        <input type="range" id="category" min=0 max=100 step=1 />
      </div>
      <div class="slide">
        <h3>Neighborhood</h3>
        <input type="range" id="neighborhood" min=0 max=100 step=1 />
      </div>
      <div class="slide">
        <h3>Rating</h3>
        <input type="range" id="rating" min=0 max=100 step=1 />
      </div>
    </div>
    <h3>Choose your Neighborhood</h3>
    <div id="neighborhood-buttons"></div>
    <h3>Choose your Category</h3>
    <div id="category-buttons"></div>
    <h3>Choose your Rating</h3>
    <div id="rating-buttons"></div>
</div>
<div class="col">
<h2>Find the perfect Boston Restaurant!</h2>
<p>Discover restaurants that closely match your interest with this interactive bubble chart! Filter restaurants by certain criteria across neighborhood, criteria, and rating! 
</p>
<svg id="bubble" height="400" width="400"></svg>
</div>
<div class="col">
  <div id = "details">
    <h3>Details:</h3>
    <div id="score">
    </div>
    </div>
    <div id="neighborhood">
    </div>
    <div id="category">
    </div>
    <div id="rating">
    </div>
  </div>
</div>
</div>
</div>

    <script>
      const bubble = d3.select("#bubble");
      const width = bubble.attr("width");
      const height = bubble.attr("height");
      const margins = { top: 10, bottom: 10, left: 30, right: 30 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      let annotations = bubble.append("g").attr("id", "annotations");
      let points = bubble
        .append("g")
        .attr("id", "points")
        .attr(
          "transform",
          "translate(" + margins.left + "," + margins.top + ")"
        );

      //initialization of global vars
      let filterTypes = ['category', 'neighborhood', 'rating']
      let selectedFilters = {"category":[], "neighborhood":[], "rating":[]}
      let weights = {'category':33, 'neighborhood':33, 'rating':33}

      const requestData = async function () {
        //LOAD DATA
        const all_restaurants = await d3.json("yelp_boston.json", d3.autoType);
        const restaurants = [...all_restaurants]
        console.log(restaurants);

        var neighborhood = d3.map(restaurants, (d) => d["neighborhood"]);
        var neighborhoodList = [...new Set(neighborhood)];
        var category = d3.map(restaurants, (d) => d["categories"]);
        var categoryList = [];
        var rating = d3.map(restaurants, (d) => d["rating"]);
        var ratingList = [...new Set(rating)];

        neighborhoodList = neighborhoodList.filter((d) => d !== "");
        let filterLists = {'category':categoryList, 'neighborhood':neighborhoodList, 'rating':ratingList}

        restaurants.forEach((d) => {
          d["score"] = calculateScore(d);
          d.x = d3.randomUniform(0, chartWidth)();
          d.y = d3.randomUniform(0, chartHeight)();
          d["categories"].forEach((c) => {
            if (!categoryList.includes(c)) {
              categoryList.push(c);
            }
          });
        });

        neighborhoodList = neighborhoodList.filter((d) => d !== "");
        console.log(categoryList);
        console.log(neighborhoodList);

        // create sliders
        filterTypes.forEach(d => {
          d3.select(`#${d}`)
            .attr('value', 33)
            .on("input", function () {
              sliderMoved(d3.select(this), d);
              resetSim();
          });
        });

        d3.select("div#sliders")
          .append("button")
          .text('Reset weights')
          .on("click", function () {
            console.log('hello');
            filterTypes.forEach(f => {
              weights[f] = 33
              d3.select(`input#${f}`).attr("value", 33)
            });
            resetSim();
          });

        // SCALES
        let scoreExtent = [0,5]
        let scoreScale = d3.scaleLinear().domain(scoreExtent).range([0, chartWidth]);
        let radScale = d3.scaleLinear().domain(scoreExtent).range([2, 12]);
        let forceScale = d3.scaleLinear().domain(scoreExtent).range([100, 10]);
        let colorScale = d3.scaleSequential().domain(scoreExtent).interpolator(d3.interpolateGreys)
        console.log(colorScale(3))

        // annotations
        //   .append("line")
        //   .attr("x1", scoreScale(scoreExtent[0]) + margins.left)
        //   .attr("x2", scoreScale(scoreExtent[1]) + margins.left)
        //   .attr("y1", chartHeight / 2 + margins.top)
        //   .attr("y2", chartHeight / 2 + margins.top)
        //   .attr("class", "dashed");

        // var scoreAxis = d3.axisBottom(scoreScale);
        // annotations
        //   .append("g")
        //   .attr("class", "x axis")
        //   .attr(
        //     "transform",
        //     `translate(${margins.left},${chartHeight - margins.top})`
        //   )
        //   .call(scoreAxis);

        points
          .selectAll("circle")
          .data(restaurants)
          .join("circle")
          .attr("r", (d) => radScale(d.score))
          .attr("cx", (d) => d.x)
          .attr("cy", (d) => d.y)
          .attr("fill", d => colorScale(d.score))
          .on("mouseover", function () {
            d3.select(this)
              .attr("r", (d) => radScale(d.score)+2)
          })
          .on("mouseout", function() {
            d3.select(this)
              .attr("r", (d) => radScale(d.score))
          });

        var simulation = d3
          .forceSimulation()
          .nodes(restaurants)
          // .force("center", d3.forceCenter()
          //                    .x(chartHeight/2)
          //                    .y(chartWidth/2)
          //                    .strength(0.05))
          .force(
            "radial",
            d3
              .forceRadial()
              .x(chartWidth / 2)
              .y(chartHeight / 2)
              .radius((d) => forceScale(d.score))
              .strength(1)
          )
          // .force("ypos", d3.forceY()
          //                  .y(chartHeight/2)
          //                  .strength(0.05))
          // .force("xpos", d3.forceX()
          //                  .x(d => {
          //                    // console.log(d)
          //                    // console.log(scoreScale(d.score))
          //                    return scoreScale(d.score)
          //                  })
          //                  .strength(0.05))
          .force(
            "collision",
            d3
              .forceCollide()
              .radius((d) => radScale(d.score) + 2)
              .iterations(2)
          )
          .on("tick", updatePoints);

        function updatePoints() {
          points
            .selectAll("circle")
            .attr("r", d => radScale(d.score))
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y)
            .attr("fill", d => colorScale(d.score));
        }

        function updateScores() {
          restaurants.forEach(d => {
            d.score = calculateScore(d)
          })
        }
        function updateDetails(d){
          if (idNumber === "") {
          details.select("#score").text("");
          details.select("#neighborhood").text("");
          details.select("#category").text("");
          details.select("#rating").text("")
        } else {
          details.select("#score").text(d.score);
          details.select("#category").text(`Categories selected: ${d.category}`);
          details.select("#neighborhood").text(`Neighborhood selected: ${d.neighborhood}`);
          details.select("#rating").text(`Rating selected: ${d.rating}`);
        }
        }
        function resetSim() {
          updateScores();
          simulation.nodes(restaurants)
          simulation.alpha(1);
          simulation.restart();
        }

        function filterClicked(elt, type) {
          selected = elt.text()
          if (elt.attr("clicked") === 'false') {
            selectedFilters[type].push(selected);
            elt.attr("clicked", "true")
            elt.classed("clicked", true)

          }
          else {
            selectedFilters[type] = selectedFilters[type].filter(d => d !== selected)
            elt.attr("clicked", "false")
            elt.classed("clicked", false)
          }

          //REFILTER DATA AND RESTART SIM
          resetSim()
        }

        function createFilters() {
          filterTypes.forEach(type => {
            container = d3.select(`div#${type}-buttons`);
            filterLists[type].forEach((d) => {
              container
                .append("button")
                .attr("clicked", "false")
                .text(d)
                .classed("clicked", false)
                .on("click", function () {
                  filterClicked(d3.select(this), type);
                });
            });
          })
        }

        function filterData() {
          filtered = []
          restaurants.forEach(d => {

          })
        }

        function sliderMoved(elt, d) {
          old_weight = weights[d]
          new_weight = parseInt(elt.property("value"));
          diff = old_weight-new_weight
          // console.log(diff)
          console.log(weights)

          others = filterTypes.filter(k => k !== d)
          if (weights[others[0]] >= 100 && diff > 0) {
            weights[others[1]] = weights[others[1]] + diff
          }
          else if (weights[others[1]] >= 100 && diff > 0) {
            weights[others[0]] = weights[others[0]] + diff
          }
          else if (weights[others[0]] <= 0 && diff < 0) {
            weights[others[1]] = weights[others[1]] + diff
          }
          else if (weights[others[1]] <= 0 && diff < 0) {
            weights[others[0]] = weights[others[0]] + diff
          }
          else {
            weights[others[0]] = weights[others[0]] + diff/2
            weights[others[1]] = weights[others[1]] + diff/2
          }

          weights[d] = new_weight

          filterTypes.forEach(f => {
            console.log(f, d3.select(`input#${f}`).attr('value'))
            d3.select(`input#${f}`).attr('value', weights[f])
            console.log(f, d3.select(`input#${f}`).attr('value'))

          })
          console.log(weights)

        }

        createFilters();
        updateDetails("");
      }; //END REQUEST DATA

      function getCommon(included, selected) {
        count = 0
        included.forEach(i => {
          if (selected.includes(i)) {
            count += 1
          }
        })

        return count
      }

      function calculateScore(d) {
        rating = d.rating;
        cat = 2.5;
        neigh = 2.5;

        // commonRating = getCommon(rating, chosenRating);
        // commonNeighborhood = getCommon(d.neighborhood, selectedFilters['neighborhood']);
        console.log(selectedFilters['category'])
        num_selected = selectedFilters['category'].length
        if (num_selected > 0) {
          common = getCommon(d.categories, selectedFilters['category']);
          cat = (common/num_selected)*5
        }
        // if (commonRating.length > 0) {
        //   res = commonRating.length;
        // } else {
        //   res = 0;
        // }
        if (selectedFilters['neighborhood'].length > 0) {
          console.log(selectedFilters['neighborhood'])
          if (selectedFilters['neighborhood'].includes(d.neighborhood)) {
            neigh = 5;
          }
          else {
            neigh = 0;
          }
        }
        // console.log(weights)
        final =
          neigh * (weights['neighborhood']/100) +
          rating * (weights['rating']/100) +
          cat * (weights['category']/100);
        // console.log(final)
        console.log(final)
        return final;
      }
      requestData();
    </script>
  </body>
</html>
